# Hibernate

— фреймворк, написанный на Java, и используемый в Java. Под капотом
используется Reflection API и JDBC.

## Назначение ORM-фреймворков

### Проблемы при использовании JDBC

![Модель подключения к БД][1]

1. Несоответствие двух моделей

   ![Модели ][2]

   В JDBC проблема решалась путем создания своей таблицы, на которую мапят
   соответствующий класс

   ![JDBC маппинг][3]

   **процесс мапинга** — преобразования табличных данных в Java классы и
   соответствующие им объекты — **очень трудоёмкий процесс** (**особенно
   преобразования типов, различных связей между таблицами и т.д.**)


2. Ручное написание простейших SQL запросов

   ![маппинг при CRUD][4]

   Операции CRUD очень часто встречаются, поэтому для каждой таблицы
   приходится писать соответствующий класс на мапинг из таблицы в класс
   и наоборот - из класса в таблицу.

   Для этого создавался слой Dao, и повторяли все основные запросы
   (`save()`, `update()`, `delete()`, `findById()`, `findAll()` и т.д.),
   каждый раз дублируя почти один и тот же код.

   Это рутинная работа, отнимающая много времени программиста,
   тогда как лучше тратить время на решение реальных проблем.


3. Отложенная загрузка данных (lazy loading)

    - Если мы создаем класс Ticket на соответствующую таблицу ticket, а
      также хотим создать класс Flight на соответствующую таблицу flight,
      то если мы захотим в объекте типа Flight создать список на все Ticket
      которые к нему относятся, а в ticket будет ссылка на flight,
      к которому он относится, то это приведёт к бесконечной рекурсии:
      достаём Flight, Flight достает все Ticket, а Ticket достанет Flight,
      к которому он относится и так по кругу.

      ![возможная рекурсия при связях][5]

4. Множество других более мелких проблем

    - наследование в классах (как это мапится в SQL и реалиционную модель)
    - сравнение объектов (по первичному ключу в СУБД VS equals в Java)
    - кэширование (если хотим исправить проблемы с performance в нашем
      приложении, то хотелось бы иметь кэширование из коробки,
      а не реализовывать его вручную)
    - управление транзакциями (в JDBC управление транзакциями довольно
      сложное, там используются блоки `try-catch-finally`)

Для решения этих проблем придумали **ORM**.
**ORM** (Object Relational Mapping) — процесс преобразования
объектно-ориентированной модели в реляционную и наоборот.

![ORM-преобразования][6]

Чтобы не писать ORM-преобразования вручную, придумали **Hibernate**.
Hibernate — это инструмент, который автоматизирует процесс преобразования
объектно-ориентированной модели в реляционную и наоборот (ORM Framework).

Таким образом, **вместо JDBC** будет использоваться **Hibernate**, а для
общения с БД будут создаваться соответствующие **сущности** (Entities)

![от JDBC к Hibernate][7]

Существует множество других ORM-фреймворков, менее распространенных, чем
Hibernate:

- JOOQ (джук)
- MyBatis
- Eclipse Link
- Apache Cayenne

## Необходимые инструменты для работы с Hibernate

- Java SE Development Kit
- IntelliJ IDEA Ultimate Edition
- PostgreSQL СУБД

    - pgAdmin 4 и Stack Builder не нужны. pgAdmin хоть и бесплатный клиент
      к
      PostgreSQL, но в реальной практике используется IntelliJ IDEA в
      качестве
      клиента для работы со всеми СУБД
    - вместо PostgreSQL, устанавливаемой на локальную машину, можно
      использовать Docker
      с [образом postgres](https://hub.docker.com/_/postgres), который
      является более универсальным и более
      предпочтительным выбором.<br>
      Суть Docker заключается в том, что мы можем установить его на
      компьютер и использовать почти любые приложения, просто
      воспользовавшиь образом, и нет нужды устанавливать Postgres
      отдельно на локальную машину. Кроме того, можно одновременно
      запускать несколько версий PostgreSQL.
      для запуска экземпляра postgres необходимо ввести в терминале
      следующую команду:
      ```bash
      docker run --name some-postgres -e POSTGRES_PASSWORD=postgres -p 5433:5432 -d postgres
      ```
      порт 5432 был занят после установки PostgreSQL как stand-alone
      приложения, поэтому будем использовать порт 5433 и будем пробрасывать
      его на порт 5432 внутри docker container

## Настройка проекта

Необходимо добавить нужные зависимости.

```groovy
implementation 'org.hibernate:hibernate-core:5.6.14.Final'
```

это implementation Configuration, т.к. зависимость нужна как на compile
фазе, так и на runtime фазе, причем как в главных классах, так и в тестовых
классах.

```groovy
runtimeOnly 'org.postgresql:postgresql:42.5.1'
```

Configuration, нужный только на runtime фазе

Чтобы убрать boiler-plate код:

```groovy
compileOnly 'org.projectlombok:lombok:1.18.24'
```

сами аннотации lombok и его классы для основных классов (в директории
`src/main`). Нужны только на этапе компиляции, т.к. потом будут
преобразованы
в обычный Java код и в runtime будут не нужны

```groovy
annotationProcessor 'org.projectlombok:lombok:1.18.24'
```

процессор, обрабатывающий аннотации в основных классах, и преобразующий их
в Java код

```groovy
testCompileOnly 'org.projectlombok:lombok:1.18.24'
```

сами аннотации lombok и его классы для тестовых классов (в директории
`src/test`). Нужны только на этапе компиляции, т.к. потом будут
преобразованы
в обычный Java код и в runtime будут не нужны

```groovy
testAnnotationProcessor 'org.projectlombok:lombok:1.18.24'
```

процессор, обрабатывающий аннотации в тестовых классах, и преобразующий их
в Java код

указываем версию используемой java:

```groovy
java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}
```

## Решение проблемы с отображением кириллических символов в консольном логе Hibernate в IntelliJ IDEA:

Необходимо добавить в файл idea.vmoptions (для лицензионной версии -
это<br>
`"C:\Program Files\JetBrains\IntelliJ IDEA 2018.3.2\bin\"`) строку

    -Dfile.encoding=UTF-8

- выставить кодировку UTF-8 для консоли
  (Editor-> General -> Console Default Encoding: UTF-8)
- выставить кодировку для проекта и глобально:
  (Editor -> File Encodings Global Encoding: UTF-8 Project Encoding: UTF-8)

## Конфигурация SessionFactory

Всё изменяемое и конфигурируемое выносят в отдельные текстовые файлы,
которые не нужно перекомпилировать, например в `application.properties`
файл:

    db.url=jdbc:postgresql://localhost:5433/postgres
    db.username=postgres
    db.password=postgres

Необходимо создание ConnectionPool на 10-20 соединений на всё приложение,
т.к. создание объекта типа Connection является дорогостоящим и
трудозатратным:

```java
BlockingDeque<Connection> pool=null;
```

Далее необходима инициализация этого пула.

Для получения объекта `Connection`, у этого пула вызывался
метод `pool.take()`

В Hibernate это выглядит немного посложнее: под капотом мы также спускаемся
до `Pool` и `Connection`, но оборачиваем их в соответствующие Hibernate
классы:

- в случае `Session` — это будет обёртка вокруг `Connection`
- в случае `SessionFactory` — это будет обёртка вокруг `Pool` (объекта, у
  которого будем получать объекты типа `Session`)

Таким образом, необходимо проинициализировать объект типа `SessionFactory`,
после чего из него можно будет получать объекты типа `Session`, и
оперировать
объектами типа `Entity`

Для этого также используется конфигурационный файл, но в отличие от
`application.properties`, это будет `hibernate.cfg.xml` файл.

![IDEA hibernate.cfg.xml][8]

Как правило этот файл располагается в `$rootDir/src/main/resources`<br>
Формат файла возможно посмотреть в [схеме DTD][9].

Главная задача этого файла — создать `SessionFactory` с соответствующими
полями:

![content of hibernate.cfg.xml ][10]

`<property name="hibernate.dialect">org.hibernate.dialect.PostgreSQLDialect10</property>`

позволяет Hibernate сконфигурировать дополнительно SQL-типы, VIEW и т.д.,
которые специфичны для конкретной СУБД. Используется для PostgreSQL версии
10 и выше.<br>
Для Hibernate 6.0 и выше, следует
использовать `org.hibernate.dialect.PostgreSQLDialect`

`<property name="show_sql">true</property>`

— позволяет видеть, **какой SQL запрос** формирует Hibernate.

`<property name="format_sql">true</property>`

— красивое форматирование SQL-запроса с отступами

![sql request example log][11]

`<mapping class="com.dmdev.entity.User"/>`

— позволяет `SessionFactory` отслеживать сущность `User`

Для создания `SessionFactory` используется
класс `org.hibernate.cfg.Configuration`

Для конфигурирования `SessionFactory` используется
метод `configure("path/to/cfg.xml")`, принимающий в качестве параметра путь
к `hibernate.cfg.xml` файлу.<br>
Если использовать метод `configure()` без
параметров, он будет использовать
путь по умолчанию: `$rootDir/src/main/resources/hibernate.cfg.xml`

Класс `Configuration` содержит всё, что нужно для
создания `SessionFactory`,
например:

- **стратегии именования** — описывает, **как** мы преобразуем названия
  классов в
  Java в соответствующие названия колонок таблиц в БД;
- какие типы поддерживает (**basicTypes**);
- именованные запросы (**namedQueries**);
- процедуры (**namedProcedureCallMap**);
- sql-функции;

  ![Configuration fields][12]

- свойства, которые используются при создании `SessionFactory`. Все эти
  свойства можно установить вручную, а можно использовать настройки по
  умолчанию;

  ![Configuration fields for creating SessionFactory][13]

- все, что связано с метаинформацией (т.е. с нашими таблицами) содержит
  поле типа `MetadataSources`. В БД **метаинформация** - это структура
  каталогов, схем, таблиц, колонок и пр.

После конфигурации у объекта типа `Configuration` вызывается метод
`buildSessionFactory()`, который возвращает объект типа `SessionFactory` на
основании всех полей в классе `Configuration` **ПЛЮС** `hibernate.cfg.xml`

Как и `ConnectionPool`, должен существовать всего лишь один объект типа
`SessionFactory` **на всё приложение**.

Обычно `SessionFactory` закрывается при остановке приложения.

Необходимо окружить `SessionFactory` блоком `try-catch`.

После создания `SessionFactory`, мы можем получать объекты типа `Session`,
путем вызова метода `openSession()`:

```java
Configuration configuration=new Configuration();
    configuration.configure();
    try(var sessionFactory=configuration.buildSessionFactory();
    var session=sessionFactory.openSession())
    {
    System.out.println("OK");
    }
```

`Session` — это обёртка вокруг объекта `Connection`, предоставляющая более
удобный функционал для Hibernate и управления его сущностями.

## Entity (сущность)

— то, что проецируется на таблицу в БД и обладает соответствующими столбцам
таблицы полями. Простые поля, не содержащие foreign key на другие
таблицы, мапить довольно просто.

Для того, чтобы созданный класс стал сущностью Hibernate, необходимо
несколько правил:

1. Сущность должна быть **POJO** (Plain Old Java Object), т.е. все поля
   должны быть private, а также должны быть геттеры/сеттеры к ним.
2. Сущность должна быть **mutable**, поэтому есть сеттеры, а поля не должны
   быть `final` (Hibernate всегда их меняет в своем жизненном цикле).
3. Сам класс также не может быть `final` (Hibernate часто работает с
   прокси-объектами, работающими по принципу **CGLIB** — code generation
   library, являющимися наследниками исходного класса).
4. Сущность обязательно должна содержать **конструктор без параметров** (
   т.к.
   Hibernate использует **Reflection API** для создания сущностей и
   последующей инициализацией через сеттеры или напрямую через Reflection
   API)
5. Сущность должна содержать **полный конструктор** для удобной
   инициализации сущности.
6. Сущность должна содержать метод `toString()`.
7. Сущность должна содержать методы `equals()` и `hashCode()`, т.к. она
   часто
   используется в коллекциях. При этом можно использовать как все поля
   сущности для сравнения с другой сущностью, так и лишь один первичный
   ключ

Поскольку в результате пишется большое количество **boilerplate-кода**,
принято
использовать **lombok аннотации**:

- `@Data` — заменяет все вышеуказанные методы (геттеры для всех полей,
  сеттеры для всех нефинальных полей, реализации `toString`, `equals`,
  `hashCode`, конструктор для всех финальных полей)
- `@NoArgsConstructor` — конструктор без параметров
- `@AllArgsConstructor`  — полный конструктор
- `@Builder` — чтобы красиво создавать и инициализировать сущности

Далее необходимо сказать, что данный POJO является Hibernate entity. Для
этого класс помечается следующей аннотацией из
пакета `jakarta.persistence`:

    @Entity — аннотация НЕ из Hibernate, а из JPA

**Каждая сущность в Hibernate должна иметь первичный ключ**. Для этого одно
из полей класса помечается обязательной аннотацией `@Id` из того же
пакета `jakarta.persistence`, чтобы невозможно было нарушить **первую
нормальную форму SQL**. Класс поля, помеченный как `@Id` обязан
реализовывать интерфейс `Serializable`. Это связано с внутренними
механизмами (кешированием).

    Таким образом, сущность в Hibernate = POJO + @Entity + @Id 

В JDBC для сохранения сущности мы делали следующее:

1. Ручное формирование SQL-запроса:

```java
SAVE_SQL="""
  INSERT INTO tableName (field1, field2, ...)
  VALUES (?, ?, ...)
""";
```

2. Передаем SAVE_SQL в prepareStatement
3. Ручной мапинг типов данных в SQL на типы данных полей сущности.

   ![JDBC save entity to DB][14]

Для сохранения созданной Hibernate сущности в БД, воспользуемся методом
объекта `Session`, принимающий в качестве параметра **Hibernate entity**:

- `session.save(user)` — **deprecated**
- `session.persist(user)` — новый метод, рекомендуемый к использованиюю

отличие `persist()` от `save()`:

- `persist()` хорошо определен. Это делает временный экземпляр постоянным.
  Однако не гарантируется, что значение идентификатора будет присвоено
  постоянному экземпляру немедленно, назначение может произойти во время
  `flush()`. `persist()` также гарантирует, что он не выполнит оператор
  `INSERT`, если он будет вызван за пределами транзакции. Это полезно
  в длительных диалогах с расширенным контекстом Session/persistence;
- `save()` не гарантирует того же, он возвращает идентификатор, и если для
  получения идентификатора необходимо выполнить `INSERT` (например,
  "identity" generator, а не sequence), этот `INSERT` происходит
  немедленно, независимо от того, находитесь ли вы внутри или вне
  транзакции. Это нехорошо в длительном диалоге с расширенным контекстом
  Session/persistence.

Кроме того, для того, чтобы отправлять запросы к БД, мы должны работать с
транзакциями.
<br>В случае с Hibernate работать с транзакциями нужно вручную, здесь
нет `AUTO_COMMIT_MODE`:

```java
session.beginTransaction();
    session.getTransaction().commit();   /* если всё хорошо */
    session.getTransaction().rollback(); /* если всё плохо */
```

Если мы не добавим в `SessionFactory` нашу сущность, то при запуске будет
выброшено исключение `org.hibernate.UnknownEntityTypeException`, т.к.
необходимо **зарегистрировать** `Entity`, чтобы `SessionFactory`
отслеживало её. Для этого есть три варианта:

- `configuration.addClass(Class persistentClass)` — принимает класс,
  который мапится с помощью xml — **устаревший способ**, т.к. сейчас никто
  не
  мапит классы с помощью xml
- `configuration.addAnnotatedClass(Class annotatedClass)` — современный
  способ добавления сущности в `SessionFactory`. Позволяет динамически
  искать в соответствующих пакетах и добавлять сущности. Этот способ
  использует Spring в своём функционале.

    ```java
    configuration.addAnnotatedClass(User.class); /* возвращает Configuration */
    ```

  Под капотом метода происходит следующее:

    ```java
    public Configuration addAnnotatedClass(Class annotatedClass){
        // добавляем annotatedClass в метамодель
        metadataSources.addAnnotatedClass(annotatedClass);
        return this;
    }
    ```

  Поле `metadataSources` объекта `SessionFactory` отвечает за сущности (
  нашу
  метаинформацию — информацию об информации)
- в `hibernate.cfg.xml` добавить mapping `<mapping class="com.dmdev.
  entity.User"/>`.

По умолчанию Hibernate берёт название класса/полей в качестве названия
таблицы/колонок в базе данных (SQL не чувствителен к регистру). Поэтому по
умолчанию метод `save()`/`persist()` вызовет ошибку, пытаясь вставить
данные в
системную таблицу `user`, тогда как необходимо осуществлять сохранение
сущности в таблицу `users`.

![Default naming mapping][15]

Таким образом, при попытке осуществить добавление сущности `User` в БД, это
добавление будет осуществляться в таблицу `user`, тогда как нам необходимо
добавление в таблицу `users` (таблица `user` **зарезервирована** под нужды
PostgreSQL), что приведёт к ошибке:

![Error caused by default table name mapping][16]

Для задания имени таблицы (если оно отличается от имени класса), куда
должно осуществляться добавление сущности, в Hibernate существует RUNTIME
аннотация (т.е. во время выполнения, мы можем получать все необходимые
свойства этой аннотации) из пакета `jakarta.persistence`, которая является
**метаинформацией** для наших классов:

`@Table(name = "users", schema = "public")`

![Table annotation][17]

Для того, чтобы IntelliJ IDEA подсказывала еще больше, мы можем присвоить
**Data Source**, который до этого подключали с помощью функционала IDEA,
после чего среда разработки будет видеть все поля таблицы:

![IDE Data Source][18]

Кроме того, существует проблема добавления поля `birthDate` сущности `User`
в
колонку `birth_date` таблицы `users`, поскольку Hibernate будет пытаться
осуществить эту вставку в несуществующую колонку `birthDate`:

![Error caused by default column name mapping][19]

    По умолчанию Hibernate берёт имена полей сущности в нижнем регистре

Если необходимо, чтобы **CamelCase** в Java формировался в **underscore** (
**snake_case** в SQL), то следует использовать другой **naming strategy**.
Для этого используется поле `physicalNamingStrategy`
типа `PhysicalNamingStrategy` класса `Configuration`.

Этот интерфейс используется для формирования названий таблиц, схем, колонок
в БД на основании названий классов и полей в Java. У этого интерфейса
есть две реализации:

- `PhysicalNamingStrategyStandardImpl` — данный класс используется по
  умолчанию
- `CamelCaseToUnderscoresNamingStrategy`

для установки необходимой стратегии существует 2 способа:

- с помощью метода `setPhysicalNamingStrategy` у объекта `Configuration`:

        configuration.setPhysicalNamingStrategy(new CamelCaseToUnderscores())

- с помощью RUNTIME аннотации `@Column` из пакета `jakarta.persistence`
  аналогичную по своему смыслу аннотации `@Table` в сущности `User`:
    ```java
    @Column(name="birth_date")
    private LocalDate birthDate;
    ```

Аннотацию `@Column` можно использовать как над **полем**, так и над *
*методом** (геттером/сеттером), но **над методом в наше время её не ставят
**, т.к. широко используется библиотека **lombok**, которая автоматически
генерирует геттеры/сеттеры.

Данная аннотация содержит большое количество метаинформации про колонки
таблицы, которую мы можем использовать для своих нужд:

- columnDefinition()
- insertable() — можно или нельзя вставлять данную колонку в БД
- length() — размер колонки (VARCHAR(128))
- name()
- nullable()
- precision() — точность, в случае если поле типа double
- scale()
- table()
- unique()
- updatable()

Hibernate также поддерживает **автоматическое создание DDL** на основании
указанной выше метаинформации.



[1]: resources/01.png

[2]: resources/02.png

[3]: resources/03.png

[4]: resources/04.png

[5]: resources/05.png

[6]: resources/06.png

[7]: resources/07.png

[8]: resources/08.png

[9]: http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd

[10]: resources/09.png

[11]: resources/10.png

[12]: resources/11.png

[13]: resources/12.png

[14]: resources/13.png

[15]: resources/14.png

[16]: resources/15.png

[17]: resources/16.png

[18]: resources/17.png

[19]: resources/18.png